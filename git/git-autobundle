#!/bin/bash

error() {
    printf "\e[1;31merror:\e[0m %s\n" "$*"
} >&2

warning() {
    printf "\e[1;33mwarning:\e[0m %s\n" "$*"
} >&2

info() { # 1:header 2:message
    printf "\e[0;34m%s:\e[0m %s\n" "$1" "$2"
}

success() { # 1:header 2:message
    printf "\e[1;32m%s:\e[0m %s\n" "$1" "$2"
}

die() {
    local rc=$?
    error "$*"
    exit $rc
} >&2

join_by() { local IFS="$1"; shift; echo "$*"; }

join_path() {
    local -a components=()
    for p in "$@"; do
        [[ -n "$p" ]] && components+=("$p")
    done
    join_by / "${components[@]}"
}

contains() { # 1:needle *:haystack
    local needle="$1" e
    shift
    for e in "$@"; do
        [[ "$needle" == "$e" ]] && return 0
    done
    return 1
}

usage() {
    local -i rc=$1
    echo "usage: git autobundle [options] <repo> [<bundle>]

options:
  -r | --recursive      recursively bundle submodules (using .gitmodules from the origin's HEAD)
  -x | --directories    create the bundle under a hierarchy of directories matching the remote repository path
  -P | --prefix DIR     create the bundle (and hierarchy if used with -x) under the provided path
  -c | --clobber yes|no|ask|skip    what to do for an already existing bundle: overwrite, fail, ask (the default), or skip
                        the short form doesn't take a value and is equivalent to \`--clobber yes\`
  -n | --dry-run        only show what would be done, but do not actually create the bundles
  -C | --clone-opt OPT  pass the provided option to \`git clone\` (cumulative)"
    exit $rc
} >&2

getopt -T &> /dev/null
(( $? != 4 )) && die "bad getopt"
getopt="$(getopt -n "${0##*/}" -l recursive,directories,prefix:,clobber:,dry-run,clone-opt:,help -o +rxP:cnC:h -- "$@")" || exit $?
eval set -- "$getopt"

recursive=false
use_directories=false
use_prefix=false
prefix=
if [[ -t 0 ]]; then
    clobber=ask
else
    clobber=no
fi
dry_run=false
clone_opts=()

while true; do
    case "$1" in
        -r|--recursive) recursive=true ;;
        -x|--directories) use_directories=true ;;
        -P|--prefix) use_prefix=true; prefix="${2:-.}"; shift ;;
        -c) clobber=yes ;;
        --clobber) clobber="${2,,}"; shift ;;
        -n|--dry-run) dry_run=true ;;
        -C|--clone-opt) clone_opts+=("$2"); shift ;;
        -h|--help) usage 0 ;;
        --) shift; break ;;
        *) die "internal error" ;;
    esac
    shift
done

case "$clobber" in
    y|ye|yes) ;;
    n|no) ;;
    a|as|ask)
        [[ -t 0 ]] || die "cannot ask to clobber existing bundles without a tty"
        ;;
    s|sk|ski|skip) ;;
    *) die "bad --clobber value: $clobber"
esac

if [[ -z "$1" ]]; then
    error "missing <repo>"
    usage 1
fi

shopt -s extglob

# list of all repos/bundles created during this run
# used for deduplication when recursing into submodules
fresh_repos=()
fresh_bundles=()

autobundle() { # 1:repo 2:bundle
    local repo base bundle abs_bundle clone skip_bundle=false

    repo="${1%%+(/)}"  # strip trailing /s
    base="${repo##*/}"
    base="${base%.git}"

    # ensure we're not going to bundle an already freshly bundled repo
    if contains "$repo" "${fresh_repos[@]}"; then
        warning "skipping already bundled repo: $repo"
        return 0
    fi

    info "Bundling repo" "$repo"

    bundle="$2"
    [[ -n "$bundle" ]] || bundle="$base".git
    if [[ "${bundle:0:1}" == / ]]; then
        # absolute bundle path, don't alter it
        $use_directories || $use_prefix && warning "absolute path provided for bundle, ignoring --directories/--prefix"
        abs_bundle=$bundle
    else
        # relative bundle path, construct its absolute path
        local dirs=()

        $use_prefix && dirs+=("$prefix")

        if $use_directories; then
            local path="${repo%/*}"
            if [[ "$path" == *://* ]]; then
                path="${path#*://}"  # strip protocol
            else
                # XXX: this assumes ssh
                path="${path/://}"   # turn : after host into /
            fi
            dirs+=("$path")
        fi

        bundle="$(join_path "${dirs[@]}" "$bundle")"
        if [[ "${bundle:0:1}" == / ]]; then
            abs_bundle="$bundle"
        else
            abs_bundle="$PWD/$bundle"
        fi
    fi

    # ensure we're not going to overwrite a freshly created bundle
    # this is different from handling a pre-existing bundle, which is governed by the --clobber behavior
    # (we already checked we haven't freshly bundled this repo so this would mean
    # a different repo resulted in the same bundle path)
    if contains "$abs_bundle" "${fresh_bundles[@]}"; then
        # should never happen with --directories, due to the $fresh_repos check earlier
        error "repo bundle path already created for another repo (try again with --directories?)"
        die "duplicate bundle path: $abs_bundle"
    fi

    # handle pre-existing bundle clobbering
    if [[ -f "$abs_bundle" ]]; then
        case "$clobber" in
            n*) die "bundle already exists: $abs_bundle" ;;
            a*)
                warning "bundle already exists: $abs_bundle"
                local ans=
                [[ -z "$ans" ]]
                while [[ -z "$ans" ]]; do
                    read -rp "         overwrite? [y/N/q] " -n1 ans
                    [[ -z "$ans" ]] || echo
                    case "${ans,,}" in
                        "") ans=n ;&
                        n)
                            if $recursive; then
                                # skip the bundle but we still need to clone the repo to recurse
                                skip_bundle=true
                            else
                                return 0
                            fi
                            ;;
                        y) ;;
                        q) exit 1 ;;
                        *) ans= ;;
                    esac
                done
                ;;
            s*)
                warning "bundle already exists, skipping: $abs_bundle"
                skip_bundle=true
                ;;
            y*) ;;
        esac
    fi

    clone="$(mktemp -d --tmpdir "autobundle.$base.XXXXXX")"
    trap 'rm -rf "$clone"' EXIT

    git clone --bare "${clone_opts[@]}" "$repo" "$clone" || die "git clone failed ${clone_opts+"(clone opts: ${clone_opts[*]})"}"

    if ! $skip_bundle; then
        if ! $dry_run; then
            mkdir -p "${abs_bundle%/*}" || die "mkdir failed"
            (cd "$clone" && git bundle create "$abs_bundle" --all) || die "git bundle failed"
            success "Bundle created" "$bundle"
        else
            success "Bundle to create" "$bundle"
        fi
    fi

    fresh_bundles+=("$abs_bundle")
    fresh_repos+=("$repo")

    if $recursive && git --git-dir "$clone" show HEAD:.gitmodules &>/dev/null; then
        # there's a gitmodules file, recurse
        local key value gm_fd gm_ok=() gm_all=()
        while IFS='=' read -r -u "$gm_fd" key value; do
            [[ "$key" == submodule.*.url ]] || continue
            local name="${key%.url}"
            name="${name#submodule.}"

            if contains "$name" "${gm_ok[@]}"; then
                warning "skipping extra submodule url: $name: $value"
                continue
            fi

            contains "$name" "${gm_all[@]}" || gm_all+=("$name")

            # submodules don't get custom bundle names (the `[<bundle>]` argument to git-autobundle)
            # NB: this turns `autobundle` into a recursive function, hopefully the git repo hierarchies
            #     out there are not sufficient to make the recursive call stack blow up
            if autobundle "$value"; then
                gm_ok+=("$name")
            else
                error "failed to bundle submodule: $name: $value"
                echo "       attempting to carry on"
            fi
        done {gm_fd}< <(git config -f <(git --git-dir "$clone" show HEAD:.gitmodules) -l)
        # XXX: we may not correctly detect `git config` failing

        (( ${#gm_ok[@]} == ${#gm_all[@]} )) || die "failed to bundle all ${#gm_all[@]} submodules"
    fi

    rm -rf "$clone" || warning "cleanup failed: $clone"
}

autobundle "$1" "$2"
